import express from 'express';
import { ProjectBuild, IProjectBuild } from '../models/Generation';
import { RepositoryDataProvider } from '../services/GitHubService';
import { IntelligentAnalysisEngine } from '../services/AIAgentService';
import { ContainerBuildEngine } from '../services/DockerService';

const router = express.Router();

// POST /api/generation/generate
router.post('/generate', async (req, res) => {
  try {
    const { githubUrl, githubToken } = req.body;

    if (!githubUrl || !githubToken) {
      return res.status(400).json({
        error: 'GitHub URL and token are required'
      });
    }

    // Create new project build record
    const projectBuild = new ProjectBuild({
      repositoryUrl: githubUrl,
      accessToken: githubToken,
      processingState: 'queued'
    });

    await projectBuild.save();

    // Start the build process asynchronously
    processProjectBuild((projectBuild as any)._id.toString());

    res.json({
      success: true,
      generationId: (projectBuild as any)._id.toString(),
      message: 'Build process started'
    });

  } catch (error) {
    console.error('Error starting build process:', error);
    res.status(500).json({
      error: 'Failed to start build process'
    });
  }
});

// GET /api/generation/status/:id
router.get('/status/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const projectBuild = await ProjectBuild.findById(id);

    if (!projectBuild) {
      return res.status(404).json({
        error: 'Project build not found'
      });
    }

    res.json({
      success: true,
      generation: {
        id: (projectBuild as any)._id.toString(),
        githubUrl: projectBuild.repositoryUrl,
        techStack: projectBuild.detectedTechnologies,
        dockerfile: projectBuild.generatedDockerfile,
        buildStatus: projectBuild.processingState,
        imageId: projectBuild.containerImageId,
        error: projectBuild.failureReason,
        createdAt: projectBuild.createdAt,
        updatedAt: projectBuild.updatedAt
      }
    });

  } catch (error) {
    console.error('Error fetching build status:', error);
    res.status(500).json({
      error: 'Failed to fetch build status'
    });
  }
});

// GET /api/generation/history
router.get('/history', async (req, res) => {
  try {
    const { page = 1, limit = 10 } = req.query;
    const skip = (Number(page) - 1) * Number(limit);

    const projectBuilds = await ProjectBuild.find()
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(Number(limit))
      .select('-accessToken'); // Exclude sensitive data

    const total = await ProjectBuild.countDocuments();

    res.json({
      success: true,
      generations: projectBuilds,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total,
        pages: Math.ceil(total / Number(limit))
      }
    });

  } catch (error) {
    console.error('Error fetching build history:', error);
    res.status(500).json({
      error: 'Failed to fetch build history'
    });
  }
});

// POST /api/generation/push-dockerfile
router.post('/push-dockerfile', async (req, res) => {
  try {
    const { generationId, commitMessage } = req.body;

    if (!generationId) {
      return res.status(400).json({
        error: 'Build ID is required'
      });
    }

    const projectBuild = await ProjectBuild.findById(generationId);
    if (!projectBuild) {
      return res.status(404).json({
        error: 'Project build not found'
      });
    }

    if (!projectBuild.generatedDockerfile) {
      return res.status(400).json({
        error: 'No Dockerfile found for this build'
      });
    }

    // Push Dockerfile to GitHub repository
    const repositoryProvider = new RepositoryDataProvider(projectBuild.accessToken);
    const success = await repositoryProvider.commitDockerfileToRepository(
      projectBuild.repositoryUrl,
      projectBuild.generatedDockerfile,
      commitMessage || 'Add Dockerfile generated by DockGen AI'
    );

    if (success) {
      res.json({
        success: true,
        message: 'Dockerfile successfully pushed to repository'
      });
    } else {
      res.status(500).json({
        error: 'Failed to push Dockerfile to repository'
      });
    }

  } catch (error) {
    console.error('Error pushing Dockerfile:', error);
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Failed to push Dockerfile to repository'
    });
  }
});

// GET /api/generation/images
router.get('/images', async (req, res) => {
  try {
    const containerBuildEngine = new ContainerBuildEngine();
    const containerImages = await containerBuildEngine.listImages();
    
    res.json({
      success: true,
      images: containerImages.map(imageName => ({
        name: imageName,
        id: imageName.split(':')[0],
        tag: imageName.split(':')[1] || 'latest'
      }))
    });
  } catch (error) {
    console.error('Error fetching Docker images:', error);
    res.status(500).json({
      error: 'Failed to fetch Docker images'
    });
  }
});

// GET /api/generation/images/:id
router.get('/images/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const containerBuildEngine = new ContainerBuildEngine();
    const containerImageInfo = await containerBuildEngine.getImageInfo(id);
    
    if (!containerImageInfo) {
      return res.status(404).json({
        error: 'Docker image not found'
      });
    }
    
    res.json({
      success: true,
      image: containerImageInfo
    });
  } catch (error) {
    console.error('Error fetching Docker image info:', error);
    res.status(500).json({
      error: 'Failed to fetch Docker image info'
    });
  }
});

// DELETE /api/generation/images/:id
router.delete('/images/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const containerBuildEngine = new ContainerBuildEngine();
    const success = await containerBuildEngine.deleteImage(id);
    
    if (success) {
      res.json({
        success: true,
        message: 'Docker image deleted successfully'
      });
    } else {
      res.status(500).json({
        error: 'Failed to delete Docker image'
      });
    }
  } catch (error) {
    console.error('Error deleting Docker image:', error);
    res.status(500).json({
      error: 'Failed to delete Docker image'
    });
  }
});

// Async function to process project build
async function processProjectBuild(buildId: string) {
  try {
    const projectBuild = await ProjectBuild.findById(buildId);
    if (!projectBuild) return;

    // Update status to analyzing
    projectBuild.processingState = 'analyzing';
    await projectBuild.save();

    // Step 1: Fetch repository
    const repositoryProvider = new RepositoryDataProvider(projectBuild.accessToken);
    let repositoryData;
    try {
      repositoryData = await repositoryProvider.retrieveRepositoryInformation(projectBuild.repositoryUrl);
    } catch (error) {
      console.log('GitHub access failed, using fallback repository data:', error);
      repositoryData = await repositoryProvider.generateFallbackRepositoryData(projectBuild.repositoryUrl);
    }

    // Step 2: Detect tech stack
    const analysisEngine = new IntelligentAnalysisEngine();
    const detectedTechnologies = await analysisEngine.analyzeProjectTechnologies(repositoryData);

    // Update tech stack
    projectBuild.detectedTechnologies = detectedTechnologies;
    await projectBuild.save();

    // Step 3: Generate Dockerfile
    console.log(`Generating Dockerfile for build ${buildId}`);
    const dockerfileContent = await analysisEngine.createContainerConfiguration(repositoryData, detectedTechnologies);
    console.log(`Dockerfile generated successfully for build ${buildId}`);

    // Update dockerfile
    projectBuild.generatedDockerfile = dockerfileContent;
    await projectBuild.save();
    console.log(`Dockerfile saved for build ${buildId}`);

    // Step 4: Build Docker image
    const containerBuildEngine = new ContainerBuildEngine();
    console.log(`Starting Docker build for build ${buildId}`);
    
    const buildResult = await containerBuildEngine.buildImage(dockerfileContent, buildId, repositoryData);
    console.log(`Docker build completed for build ${buildId}:`, buildResult.success);
    console.log(`üîç BuildResult details:`, JSON.stringify(buildResult, null, 2));

    if (buildResult.success) {
      projectBuild.processingState = 'completed';
      projectBuild.containerImageId = buildResult.imageId;
      console.log(`Build ${buildId} completed successfully with image: ${buildResult.imageId}`);
      console.log(`Setting containerImageId to: ${buildResult.imageId}`);
    } else {
      projectBuild.processingState = 'failed';
      projectBuild.failureReason = buildResult.error;
      console.log(`Build ${buildId} failed with error: ${buildResult.error}`);
    }

    await projectBuild.save();
    console.log(`Build ${buildId} status updated to: ${projectBuild.processingState}`);
    console.log(`Build ${buildId} containerImageId after save: ${projectBuild.containerImageId}`);

  } catch (error) {
    console.error('Error processing build:', error);
    
    try {
      const projectBuild = await ProjectBuild.findById(buildId);
      if (projectBuild) {
        projectBuild.processingState = 'failed';
        projectBuild.failureReason = error instanceof Error ? error.message : 'Unknown error';
        await projectBuild.save();
      }
    } catch (updateError) {
      console.error('Error updating build status:', updateError);
    }
  }
}

export default router;
